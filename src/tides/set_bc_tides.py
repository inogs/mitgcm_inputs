import argparse
import json
import os
from datetime import datetime as dt
from pathlib import Path

import julian
import numpy as np
import pyTMD
from scipy.interpolate import interp1d


def create_tide_bc_second(
    path_results,
    path_tides,
    tide_model,
    tide_num,
    cbdry_used,
    grid_dims,
    time_nodal,
    endian_val,
):



    """ "
    Input: grid[0] the size of first dimension of MITgcm domain
    grid[1] the size of second dimension of MITgcm domain
    cbdry_used, cell array specify which boundary to add tidal
    boundary condition,
    {'s', 'n', 'w', 'e'}, South, North, West, and East
    If there is no ocean points on one boundary, do not specify it.
    Otherwise it will generate an error in interpolation.
    For this case, use tide_bc_empty to generate a zero amplitude tide BC.
    tide_num: tidal components to be included in tidal BC file
    time_nodal: time for nodal correction
    Output: Tidal boundary condition files will be generated with names like
        OB[N,S,E,W][am,ph].seaice_obcs
    Note:
    1) The script will read boundary grid file bdry_grid_[swne].mat
        generated by create_bc_grid.m
    2) The script will use  CAT2008b to generate tidal bc files
        with names like
        OB[NSWE]am.seaice_obcs, for tidal current amplitude   (m/s)
        OB[NSWE]ph.seaice_obcs, phase in seconds  (s)
    3) The following ten  tidal constituents can be included
              m2  s2  n2  k2  k1  o1  p1  q1 mf mm
              1   2   3   4   5   6   7   8  9  10
    4) The phase generated here inludes the Greenwich Phase of tidal
        constituent, nodal correction term, and a time constant in order to use
        nodal correction formula of CAT2008b
        phase_in_second = ( tidal_period*phase_in_radian/2*pi - mitgcm_timec)
    """

    # Constants
    sec_in_day = 86400
    # not used c8 = 8,  c4 =4

    # Dimension of Boundary files
    NX = grid_dims[0]
    NY = grid_dims[1]

    # Set the Boundary to add tides
    # AngleCS_bc, AngleSN_bc are the Cos and Sin and angle
    # of U axis of MITgcm
    # from due east

    for c_bdry in cbdry_used:

        bdry_file = path_results / f"bdry_grid_{c_bdry}.npy"
        print(bdry_file)
        data = np.load(bdry_file, allow_pickle=True).item()
        for name, arr in data.items():
            print("loaded_array:\n", name, arr.shape)
            print(name, arr.shape,"min/max:", np.nanmin(arr), np.nanmax(arr))
        lat_bc = data["lat_bc"]
        lon_bc = data["lon_bc"]
        depth_bc = data["depth_bc"]
        AngleCS_bc = data["AngleCS_bc"]
        AngleSN_bc = data["AngleSN_bc"]

        boundary = c_bdry.upper()

        OBlength = NX if boundary in ["N", "S"] else NY
        print("\n --------------------------------------------------\n")
        print(
            "Computing Tidal forcing on boundary",
            c_bdry,
            "\n over a grid of lon size",
            len(lon_bc),
            "and lat size",
            len(lat_bc),
        )
        ## Load tide model

        # TMDwidgets = pyTMD.tools.widgets()
        # TMDwidgets.directory.value = path_tides
        # print("directory", TMDwidgets.directory.value)
        # model = pyTMD.io.model(
        #     TMDwidgets.directory.value, compressed=TMDwidgets.compress.value
        # ).current(tide_model)

        model = pyTMD.io.model(path_tides).current(tide_model)

        ## Extract tidal constants for each constituent (harmonic constants)

        # Returned phases are Greenwich phases or Greenwich phase lag (in degrees)
        # pyTMD returns one value per boundary grid point for each constituent
        # in tide_num. However some points are NaN and these NaNs can appear
        # anywhere along the boundary. Because of this we later do intp_line_safe
        uamp, upha, conlist0 = model.extract_constants(
            lon_bc,
            lat_bc,
            type="U",
            constituents=tide_num,
            method="bilinear",
            extrapolate="linear",
        )
        vamp, vpha, conlist0 = model.extract_constants(
            lon_bc,
            lat_bc,
            type="V",
            constituents=tide_num,
            method="bilinear",
            extrapolate="linear",
        )

        print("Tidal constants extracted in ", c_bdry, " boundary")

        if uamp.shape[0] != len(tide_num):
            uamp = np.transpose(uamp)
            vamp = np.transpose(vamp)
            upha = np.transpose(upha)
            vpha = np.transpose(vpha)

        ## Compute nodal corrections for each constituent at time_nodal
        time0 = time_nodal
        # print(time0.strftime("%j"))
        # time1992 = dt(1992, 1, 1)
        # time_diff = (time0 - time1992).days + 48622
        # print("time0", time0)
        # print("time1992", time1992)
        # print("time diff", time_diff)

        MJD = julian.to_jd(time0, fmt="mjd")

        pu, pf, G = nodal(MJD, conlist0)

        print("Nodal corrections in radians:\n", pu, "\n", pf)

        ## Get constituent parametres

        # amp     = np.zeros(len(tide_num))
        ph      = np.zeros(len(conlist0))
        omega   = np.zeros(len(conlist0))
        # alpha   = np.zeros(len(tide_num))
        # species = np.zeros(len(tide_num))

        for i, c in enumerate(conlist0):
            amp_c, ph_c, omega_c, alpha_c, species_c = pyTMD.arguments._constituent_parameters(c)

            omega[i] = omega_c # rad/s
            ph[i]    = ph_c # rad

        period = 2*np.pi/omega #seconds

        ## Loop over constituents

        # create out arrays for all boundary points and all constituents data
        L = NX if boundary in ['N','S'] else NY

        amp_out = np.zeros((L, len(conlist0)))
        pha_out_deg = np.zeros((L, len(conlist0)))
        pha_out_sec = np.zeros((L, len(conlist0)))


        print("Filling NaNs along the boundary and applying corrections for each constitutent")
        for i, c in enumerate(conlist0):

            coord_1d = np.arange(len(uamp[i,:]))

            ua_c = intp_line_safe(uamp[i,:], coord_1d) # Fill NaNs along a 1-D boundary line
            up_c = intp_line_safe(upha[i,:], coord_1d)
            va_c = intp_line_safe(vamp[i,:], coord_1d)
            vp_c = intp_line_safe(vpha[i,:], coord_1d)

            # Apply nodal correction
            # Tidal prediction in MItgcm will be:
            # pf*amp*cos[omega(t-time0+time0-time1992) -(pha - ph - pu)], where pha-ph-pu
            # will be the phase output from this script that we will give to the MITgcm

            ua_c *= pf[0,i] #dims of pf are= 1,len(tide_num), 1 because we only calculate nodal corrections for one
            va_c *= pf[0,i]
            up_c = np.deg2rad(up_c) - ph[i] - pu[0,i]
            vp_c = np.deg2rad(vp_c) - ph[i] - pu[0,i]

            up_c = np.rad2deg(up_c)
            vp_c = np.rad2deg(vp_c)

            # depth normalized velocities
            ua_c /= depth_bc
            va_c /= depth_bc

            # rotate into model grid
            ua_cr, up_cr, va_cr, vp_cr = tide_rot(ua_c, up_c, va_c, vp_c, AngleCS_bc, AngleSN_bc)

            # save data in these arrays
            time1992 = dt(1992, 1, 1)
            mitgcm_timec = (time_nodal - time1992).days * sec_in_day

            if boundary in ["N", "S"]:
                amp_out[:, i] = va_cr
                pha_out_deg[:,i] = vp_cr
                pha_out_sec[:, i] = (period[i] * np.deg2rad(vp_cr) / (2 * np.pi)- mitgcm_timec)
            else:
                amp_out[:, i] = ua_cr
                pha_out_deg[:,i] = up_cr
                pha_out_sec[:, i] = (period[i] * np.deg2rad(up_cr) / (2 * np.pi)- mitgcm_timec)

        amp_out[np.isnan(amp_out)] = 0
        pha_out_deg[np.isnan(pha_out_deg)] = 0
        pha_out_sec[np.isnan(pha_out_sec)] = 0

        print("Saving results for each constitutent")

        fname_lon = "data_lon_" + c_bdry + ".npy"
        fname_lat = "data_lat_" + c_bdry + ".npy"
        fname_depth = "data_depth_" + c_bdry + ".npy"
        fname_am_all = "data_am_all_" + c_bdry + ".npy"
        fname_ph_all = "data_ph_all_" + c_bdry + ".npy"
        fname_ph_all_deg = "data_ph_all_deg_" + c_bdry + ".npy"


        np.save(path_results / fname_lon, lon_bc)
        np.save(path_results / fname_lat, lat_bc)
        np.save(path_results / fname_depth, depth_bc)

        np.save(path_results / fname_am_all, amp_out)
        np.save(path_results / fname_ph_all, pha_out_sec)
        np.save(path_results / fname_ph_all_deg, pha_out_deg)

        fld = ["am", "ph"]
        cfld = fld[0]
        fnm = path_results / f"OB{boundary}{cfld}_med.tide_obcs"
        writebin(str(fnm), amp_out, endian=endian_val)

        cfld = fld[1]
        fnm = path_results / f"OB{boundary}{cfld}_med.tide_obcs"
        writebin(str(fnm), pha_out_sec, endian=endian_val)

    return True


def tide_rot(ua_c, up_c, va_c, vp_c, angleCS, angleSN):
    """
    Rotate tidal current parameter from NS and EW to a new coordinate
    defined by angleCS and angleSN
    Input:
       ua_c, up_c(in deg)
       va_c, vp_c(in deg)
       AngleCS  angleSN:  cos(alpha), sin(alpha);
       alpha is the angle between new coordinate (ua_cr, va_cr)
       and due east
    Output:
        ua_cr, up_cr(in deg)
        va_cr, vp_cr(in deg);
    Both input and output are assumed (1 L) array "
    """
    # Convert degrees to radians
    up_c = np.deg2rad(up_c)
    vp_c = np.deg2rad(vp_c)

    # Calculate the new u-component amplitude and phase
    u1_p1 = ua_c * angleCS * np.cos(
        up_c
    ) + va_c * angleSN * np.cos(vp_c)
    u1_p2 = ua_c* angleCS * np.sin(
        up_c
    ) + va_c * angleSN * np.sin(vp_c)

    ua_cr = np.sqrt(u1_p1**2 + u1_p2**2)

    # sin1 = u1_p2 / ua_cr
    # cos1 = u1_p1 / ua_cr
    # up_cr = np.arctan2(sin1, cos1)
    # up_cr = np.rad2deg(up_cr)
    up_cr = np.zeros_like(ua_cr)
    mask = ua_cr > 0 # To ensure that we do not divide by 0
    up_cr[mask] = np.rad2deg(np.arctan2(u1_p2[mask], u1_p1[mask]))

    # Calculate the new v-component amplitude and phase
    v1_p1 = -ua_c * angleSN * np.cos(
        up_c
    ) + va_c * angleCS * np.cos(vp_c)
    v1_p2 = -ua_c * angleSN * np.sin(
        up_c
    ) + va_c * angleCS * np.sin(vp_c)
    va_cr = np.sqrt(v1_p1**2 + v1_p2**2)
    # sin1 = v1_p2 / va_cr
    # cos1 = v1_p1 / va_cr
    # vp_cr = np.arctan2(sin1, cos1)
    # vp_cr = np.rad2deg(vp_cr)
    vp_cr = np.zeros_like(va_cr)
    mask = va_cr > 0 # To ensure that we do not divide by 0
    vp_cr[mask] = np.rad2deg(np.arctan2(v1_p2[mask], v1_p1[mask]))

    # Return the new amplitudes and phases
    return ua_cr, up_cr, va_cr, vp_cr


def nodal(MJD, conlist):
    """
    function to compute nodal corrections for tidal constituents
    USAGE:
    [pu,pf,G]=nodal(MJD,tide_num)
    PARAMETERS:
    MJD: Modified Julian Date
    tide_num: list of tidal constituents
    OUTPUT:
    pu, pf: nodal corrections for the constituents
    G: phase correction in degrees
    """
    pu, pf, G = pyTMD.arguments.arguments(
        MJD, conlist)  # pu in radians and G in degrees
    return pu, pf, G


def intp_line_safe(values, coord):
    """
    Fill NaNs along a 1-D boundary line
    Input:  values, has NaN, coord=index of values
    Output: values_int, does not have Nan
    """
    # Identify the indices of bad (NaN or infinite) and good
    # (finite) values in utide
    badp = ~np.isfinite(values)
    goodp = np.isfinite(values)

    if np.sum(goodp) < 2:
        return np.zeros_like(values)

    # Perform linear interpolation for bad values using good values
    f = interp1d(
        coord[goodp], values[goodp], kind="linear", fill_value="extrapolate"
    )

    values_int = values.copy()
    values_int[badp] = f(coord[badp]) #Fill missing points by loooking at neighboring points
    return values_int


def tide_bc_empty(grid, cbdry_used, tide_num, path_results, endian_val):
    """
    Make a dummy tidal boundary condition based on the size of nx and ny
    with zero amplitude and phase.
     Input: nx, first   dimension of MITgcm
            ny, second  dimension of MITgcm
            tide_num, used to decide the dimension of boundary bc file
            [length, num of tidal constituent]
            cddry_used, boundary {'s', 'n', 'w', 'e'} to generate empty
            tidal bc file
    tide_num[nc<10], Which tide to include,
                    m2  s2  n2  k2  k1  o1  p1  q1  mf  mm
                    1   2   3   4   5   6   7   8   9   10
    OB[N,S,E,W][am,ph]File :: Files with boundary conditions,
    the letter combinations mean:
              N/S/E/W   :: northern/southern/eastern/western boundary
              am/ph     :: tidal amplitude (m/s) / radian
    # Example usage
    nx = 50  # Example dimension
    ny = 60  # Example dimension
    cbdry_used = ['s', 'n', 'e', 'w']
    tide_num = [1, 2, 3, 4]  # Example tide numbers
    tide_bc_empty(nx, ny, cbdry_used, tide_num)
    """
    # Set the Boundary to add tides
    print("---> Preparing empty", cbdry_used, "boundary")
    # Iterate over boundary conditions
    for c_bdry in cbdry_used:
        c_bdry = c_bdry.upper()

        # Define boundary lengths
        if c_bdry in ["N", "S"]:
            OBlength = grid[0]
        else:
            OBlength = grid[1]

        # Initialize amplitude and phase arrays
        amp_out = np.zeros((OBlength, len(tide_num)))
        pha_out_sec = np.zeros((OBlength, len(tide_num)))

        # Write amplitude file
        amp_filename = path_results / f"OB{c_bdry}am_med.tide_obcs"
        writebin(str(amp_filename), amp_out, endian=endian_val)

        # Write phase file
        ph_filename = path_results / f"OB{c_bdry}ph_med.tide_obcs"
        writebin(str(ph_filename), pha_out_sec, endian=endian_val)
    return

def writebin(fnam, fld, prec="float32", endian="big", skip=0, typ=1):
    """
    Write N-D binary field to a file.

    Parameters
    ----------
    fnam : str
        Output file name
    fld : ndarray
        Data to write
    prec : str
        Precision ('float32', 'float64', ...)
    endian : str
        'big' or 'little'
    skip : int
        Number of records to skip
    typ : int
        1 = plain binary (MITgcm style)
        0 = sequential FORTRAN (NOT implemented)
    """

    if typ != 1:
        raise NotImplementedError("Sequential FORTRAN (typ=0) not supported")

    endian_map = {"big": ">", "little": "<"}
    prec_map = {
        "float32": "f4",
        "float64": "f8",
        "int16": "i2",
        "int32": "i4",
        "int64": "i8",
    }

    if endian not in endian_map:
        raise ValueError("endian must be 'big' or 'little'")
    if prec not in prec_map:
        raise ValueError(f"Unsupported precision: {prec}")

    dtype = np.dtype(endian_map[endian] + prec_map[prec])
    fld = np.asarray(fld, dtype=dtype)

    mode = "r+b" if os.path.exists(fnam) else "wb"

    with open(fnam, mode) as f:
        if skip > 0:
            f.seek(skip * fld.size * dtype.itemsize, 0)
        f.write(fld.tobytes())

# ##
#
# path_results="/home/sgaliana/ShareMER_tides/Resulting_NWMed_tide_files/"
# path_tides= "/mnt/marraix/users/savitri/"
# tide_model="TPXO10-atlas-v2"
# tide_num=["m2", "s2"]
# boundaries=["s"]
# cbdry_used=["s"]
# grid_dims=[850,664,61]
# endian_val="little"
#
# time_nodal = dt(1979, 1, 1, 0, 0, 0)
# print("Nodal time", time_nodal, julian.to_jd(time_nodal, fmt="jd"))
#
# bnd_list = ["n", "s", "w", "e"]
# cbdry_empty = [c for c in bnd_list if c not in boundaries]
#
# path_results = Path(path_results).expanduser().resolve()
# path_tides = Path(path_tides).expanduser().resolve()
#
#
# # Constants
# sec_in_day = 86400
# # not used c8 = 8,  c4 =4
#
# # Dimension of Boundary files
# NX = grid_dims[0]
# NY = grid_dims[1]
#
# # Set the Boundary to add tides
# # AngleCS_bc, AngleSN_bc are the Cos and Sin and angle
# # of U axis of MITgcm
# # from due east
#
# for c_bdry in cbdry_used:
#
#     bdry_file = path_results / f"bdry_grid_{c_bdry}.npy"
#     print(bdry_file)
#     data = np.load(bdry_file, allow_pickle=True).item()
#     for name, arr in data.items():
#         print("loaded_array:\n", name, arr.shape)
#         print(name, arr.shape,"min/max:", np.nanmin(arr), np.nanmax(arr))
#     lat_bc = data["lat_bc"]
#     lon_bc = data["lon_bc"]
#     depth_bc = data["depth_bc"]
#     AngleCS_bc = data["AngleCS_bc"]
#     AngleSN_bc = data["AngleSN_bc"]
#
#     boundary = c_bdry.upper()
#
#     OBlength = NX if boundary in ["N", "S"] else NY
#     print("\n --------------------------------------------------\n")
#     print(
#         "Computing Tidal forcing on boundary",
#         c_bdry,
#         "\n over a grid of lon size",
#         len(lon_bc),
#         "and lat size",
#         len(lat_bc),
#     )
#     ## Load tide model
#
#     # TMDwidgets = pyTMD.tools.widgets()
#     # TMDwidgets.directory.value = path_tides
#     # print("directory", TMDwidgets.directory.value)
#     # model = pyTMD.io.model(
#     #     TMDwidgets.directory.value, compressed=TMDwidgets.compress.value
#     # ).current(tide_model)
#
#     model = pyTMD.io.model(path_tides).current(tide_model)
#
#     ## Extract tidal constants for each constituent (harmonic constants)
#
#     # Returned phases are Greenwich phases or Greenwich phase lag (in degrees)
#     # pyTMD returns one value per boundary grid point for each constituent
#     # in tide_num. However some points are NaN and these NaNs can appear
#     # anywhere along the boundary. Because of this we later do intp_line_safe
#     uamp, upha, conlist0 = model.extract_constants(
#         lon_bc,
#         lat_bc,
#         type="U",
#         constituents=tide_num,
#         method="bilinear",
#         extrapolate="linear",
#     )
#     vamp, vpha, conlist0 = model.extract_constants(
#         lon_bc,
#         lat_bc,
#         type="V",
#         constituents=tide_num,
#         method="bilinear",
#         extrapolate="linear",
#     )
#
#     print("Tidal constants extracted in ", c_bdry, " boundary")
#
#     if uamp.shape[0] != len(tide_num):
#         uamp = np.transpose(uamp)
#         vamp = np.transpose(vamp)
#         upha = np.transpose(upha)
#         vpha = np.transpose(vpha)
#
#     ## Compute nodal corrections for each constituent at time_nodal
#     time0 = time_nodal
#     # print(time0.strftime("%j"))
#     # time1992 = dt(1992, 1, 1)
#     # time_diff = (time0 - time1992).days + 48622
#     # print("time0", time0)
#     # print("time1992", time1992)
#     # print("time diff", time_diff)
#
#     MJD = julian.to_jd(time0, fmt="mjd")
#
#     pu, pf, G = nodal(MJD, conlist0)
#
#     print("Nodal corrections in radians:\n", pu, "\n", pf)
#
#     ## Get constituent parametres
#
#     # amp     = np.zeros(len(tide_num))
#     ph      = np.zeros(len(conlist0))
#     omega   = np.zeros(len(conlist0))
#     # alpha   = np.zeros(len(tide_num))
#     # species = np.zeros(len(tide_num))
#
#     print("Extracting constituent parameters for each constitutent")
#
#     for i, c in enumerate(conlist0):
#         amp_c, ph_c, omega_c, alpha_c, species_c = pyTMD.arguments._constituent_parameters(c)
#
#         omega[i] = omega_c # rad/s
#         ph[i]    = ph_c # rad
#
#     period = 2*np.pi/omega #seconds
#
#     ## Loop over constituents
#
#     # create out arrays for all boundary points and all constituents data
#     L = NX if boundary in ['N','S'] else NY
#
#     amp_out = np.zeros((L, len(conlist0)))
#     pha_out_sec = np.zeros((L, len(conlist0)))
#
#     print("Filling NaNs along the boundary and applying corrections for each constitutent")
#
#     for i, c in enumerate(conlist0):
#
#         coord_1d = np.arange(len(uamp[i,:]))
#
#         ua_c = intp_line_safe(uamp[i,:], coord_1d) # Fill NaNs along a 1-D boundary line
#         up_c = intp_line_safe(upha[i,:], coord_1d)
#         va_c = intp_line_safe(vamp[i,:], coord_1d)
#         vp_c = intp_line_safe(vpha[i,:], coord_1d)
#
#         # Apply nodal correction
#         # Tidal prediction in MItgcm will be:
#         # pf*amp*cos[omega(t-time0+time0-time1992) -(pha - ph - pu)], where pha-ph-pu
#         # will be the phase output from this script that we will give to the MITgcm
#
#         ua_c *= pf[0,i] #dims of pf are= 1,len(tide_num), 1 because we only calculate nodal corrections for one time
#         va_c *= pf[0,i]
#         up_c = np.deg2rad(up_c) - ph[i] - pu[0,i]
#         vp_c = np.deg2rad(vp_c) - ph[i] - pu[0,i]
#
#         up_c = np.rad2deg(up_c)
#         vp_c = np.rad2deg(vp_c)
#
#         # depth normalized velocities
#         ua_c /= depth_bc
#         va_c /= depth_bc
#
#         # rotate into model grid
#         ua_cr, up_cr, va_cr, vp_cr = tide_rot(ua_c, up_c, va_c, vp_c, AngleCS_bc, AngleSN_bc)
#
#         # save data in these arrays
#         time1992 = dt(1992, 1, 1)
#         mitgcm_timec = (time_nodal - time1992).days * sec_in_day
#
#         if boundary in ["N", "S"]:
#             amp_out[:, i] = va_cr
#             pha_out_sec[:, i] = (period[i] * np.deg2rad(vp_cr) / (2 * np.pi)- mitgcm_timec)
#         else:
#             amp_out[:, i] = ua_cr
#             pha_out_sec[:, i] = (period[i] * np.deg2rad(up_cr) / (2 * np.pi)- mitgcm_timec)
#
#     amp_out[np.isnan(amp_out)] = 0
#     pha_out_sec[np.isnan(pha_out_sec)] = 0
#
#     print("Saving results for each constitutent")
#
#     fname_lon = "data_lon_" + c_bdry + ".npy"
#     fname_lat = "data_lat_" + c_bdry + ".npy"
#     fname_depth = "data_depth_" + c_bdry + ".npy"
#     fname_am_all = "data_am_all_" + c_bdry + ".npy"
#     fname_ph_all = "data_ph_all_" + c_bdry + ".npy"
#
#     np.save(path_results / fname_lon, lon_bc)
#     np.save(path_results / fname_lat, lat_bc)
#     np.save(path_results / fname_depth, depth_bc)
#
#     np.save(path_results / fname_am_all, amp_out)
#     np.save(path_results / fname_ph_all, pha_out_sec)
#
#     fld = ["am", "ph"]
#     cfld = fld[0]
#     fnm = path_results / f"OB{boundary}{cfld}_med.tide_obcs"
#     writebin(str(fnm), amp_out, endian=endian_val)
#
#     cfld = fld[1]
#     fnm = path_results / f"OB{boundary}{cfld}_med.tide_obcs"
#     writebin(str(fnm), pha_out_sec, endian=endian_val)


def main(path_results, path_tides, tide_model, constituents, boundaries, grid_dims, endianess):
    print("\n-----------------------------------------------------")
    print(f"Results path:          {path_results}")
    print(f"Tidal hc data path:    {path_tides}")
    print(f"Tidal model of hc data:{tide_model}")
    print(f"Constituents:          {constituents}")
    print(f"Boundaries:            {boundaries}")
    print(f"Grid dimensions:       {grid_dims}")
    print(f"MITgcm data endianess: {endianess}")
    print("\n-----------------------------------------------------")
    print("\nCreating MITgcm Tidal BC")

    # Time for nodal correction
    time_nodal = dt(1979, 1, 1, 0, 0, 0)
    print("Nodal time", time_nodal, julian.to_jd(time_nodal, fmt="jd"))

    bnd_list = ["n", "s", "w", "e"]
    cbdry_empty = [c for c in bnd_list if c not in boundaries]
    grid_dims = list(map(int, grid_dims))

    path_results = Path(path_results).expanduser().resolve()
    path_tides = Path(path_tides).expanduser().resolve()

    # check empty lists
    if boundaries:
        print("Domain sides", boundaries, "with constituents", constituents)
        create_tide_bc_second(
            path_results,
            path_tides,
            tide_model,
            constituents,
            boundaries,
            grid_dims,
            time_nodal,
            endianess,
        )

    if cbdry_empty:
        # Create a dummy boundary condition file for eastern
        # and northern boundary
        print("Empty boundaries", cbdry_empty)
        tide_bc_empty(grid_dims, cbdry_empty, constituents, path_results, endianess)


if __name__ == "__main__":
    # load default values from JSON (if exists)
    default_config = {}
    json_path = "tides_config.json"
    if Path(json_path).exists():
        with open(json_path) as f:
            default_config = json.load(f)
    # if present set up argparse that overrides JSON
    parser = argparse.ArgumentParser(
        description="Script for creating tidal boundary condition\
        for MITgcm (*.obcs)\ninputs can be provided by json dictionary\
        and/or by command line,ls\nthese overide json inputs."
    )
    subparsers = parser.add_subparsers(title="subcommand", dest="subcommand")
    parser.add_argument(
        "--path_results",
        default=default_config.get("path_results"),
        help=(
            "path to the folder where results are saved and where the results of\
            set_bc_grid have been saved"
        ),
    )
    parser.add_argument(
        "--path_tide_hc_data",
        default=default_config.get("path_tide_hc_data"),
        help=("path to the folder containing tide hc data"),
    )
    parser.add_argument(
        "--tide_model",
        default=default_config.get("tide_model"),
        help=("name of the tide model"),
    )

    parser.add_argument(
        "--constituents",
        nargs="+",  # accetta una lista di valori separati da spazio
        default=default_config.get("constituents"),
        help=("Constituent list"),
    )
    parser.add_argument(
        "--boundaries",
        nargs="+",  # accetta una lista di valori separati da spazio
        default=default_config.get("boundaries"),
        help=("Boundary list where tides have to be added"),
    )
    parser.add_argument(
        "--grid_dims",
        nargs="+",  # accetta una lista di valori separati da spazio
        default=default_config.get("grid_dims"),
        help="number of grid points in each dimension (longitude, latitude, depth): nx, ny, nz",
    )
    parser.add_argument(
        "--binary_data_endianess",
        default=default_config.get("binary_data_endianess"),
        help="MITgcm binary data endianess",
    )


    args = parser.parse_args()

    main(
        args.path_results,
        args.path_tide_hc_data,
        args.tide_model,
        args.constituents,
        args.boundaries,
        args.grid_dims,
        args.binary_data_endianess,
    )
